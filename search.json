[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Affine and polynomial methods for signatures",
    "section": "",
    "text": "The code documentation is available at https://sarasvaluto.github.io/AffPolySig/.\nThe original theoretical results can be found in the following papers.\n\nC. Cuchiero, G. Gazzani, J. Möller, and S. Svaluto-Ferro. Joint calibration to SPX and VIX options with signature-based models. ArXiv e-prints, 2023. https://arxiv.org/abs/2301.13235.\nC. Cuchiero, S. Svaluto-Ferro, and J. Teichmann. Signature SDEs from an affine and polynomial perspectiv. ArXiv e-prints, 2023. http://arxiv.org/abs/2302.01362"
  },
  {
    "objectID": "index.html#how-to-install",
    "href": "index.html#how-to-install",
    "title": "Affine and polynomial methods for signatures",
    "section": "How to install",
    "text": "How to install\nAfter cloning the repository, cd (change directory) to the repo and enter this into your terminal:\npip install -e ."
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Affine and polynomial methods for signatures",
    "section": "How to use",
    "text": "How to use\n\nExpected signature and moments of a polynomial process\nThe goal of this code is to compute the expected signature \\(\\mathbb E[\\mathbb X_T]\\) of a polynomial process \\(X\\). In the one dimensional case it also provides an expression for its moments. As a first step import the following functions.\n\nfrom aff_poly_sig.exp_sig import expsig, withwords, expsig_withwords, moments\n\nNext, define the parameters of the polynomial process of interest. Given the drift vector \\[b(X_t)^i=b_i+\\sum_{j=0}^db_{ij}X_t^j,\\] and the diffusion matrix \\[a(X_t)^{ij}=a_{ij}+\\sum_{k=0}^da_{ijk}X_t^k+\\sum_{k,h=0}^da_{ijkh}X_t^kX_t^h,\\] we use the following parametrisation of the characteristics \\[\\begin{align*}\nb_{const}[i]&=b_i,& b_{lin}[i,j]&=b_{ij},\\\\\na_{const}[i,j]&=a_{ij},& a_{lin}[i,j,k]&=a_{ijk},& a_{quad}[i,j,k,h]=a_{ijkh}.\n\\end{align*}\\] Coefficients need then to be saved in a tuple as illustrated in the code below. Define also the initial condition \\(x_0\\).\nFor this example we consider a one dimensional Jacobi process without drift setting \\(b(X_t)^0=0\\) and \\(a(X_t)^{00}=X_t^0(1-X_t)^0\\). We set \\(x_0=1/2\\).\n\nimport numpy as np\n\n#Dimension of the process\ndim=1\n\n#Coefficients of the characteristics\nb_const=np.zeros(dim)\nb_lin=np.zeros((dim,dim))\na_const=np.zeros((dim,dim))\na_lin=np.zeros((dim,dim,dim))\na_quad=np.zeros((dim,dim,dim,dim))\n\na_lin[0]=1\na_quad[0]=-1\n\ncoeff=(b_const,b_lin,a_const,a_lin,a_quad)\n\nx0=np.zeros(dim)\nx0[0]=1/2\n\nThe last parameters to define are given by the lenght of the expected signature we would like to compute (len_max) and the time at which we would like to do it (T).\n\nlen_max=10\nT=1\n\nTo get the expected signature we can then use the function expsig.\n\nexpsig(coeff,x0,len_max,dim,T)\n\n\n\n\narray([1.00000000e+00, 0.00000000e+00, 7.90150699e-02, 0.00000000e+00,\n       1.45583443e-03, 0.00000000e+00, 1.14548260e-05, 0.00000000e+00,\n       4.94622744e-08, 0.00000000e+00, 1.34438690e-10])\n\n\nTo obtain a better readable output one can use the function withwords.\n\nE=expsig(coeff,x0,len_max,dim,T)\nwithwords(E,dim)\n\n\n\n\n[[1.0, []],\n [0.07901506985356974, [0, 0]],\n [0.0014558344297645905, [0, 0, 0, 0]],\n [1.145482602482784e-05, [0, 0, 0, 0, 0, 0]],\n [4.94622743536099e-08, [0, 0, 0, 0, 0, 0, 0, 0]],\n [1.3443868989326117e-10, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]\n\n\nThe same result can be obtained directly using expsig_withwords, which combines the two steps above.\n\nexpsig_withwords(coeff,x0,len_max,dim,T)\n\n\n\n\n[[1.0, []],\n [0.07901506985356974, [0, 0]],\n [0.0014558344297645905, [0, 0, 0, 0]],\n [1.145482602482784e-05, [0, 0, 0, 0, 0, 0]],\n [4.94622743536099e-08, [0, 0, 0, 0, 0, 0, 0, 0]],\n [1.3443868989326117e-10, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]\n\n\nIn one dimension (dim=1) we can also use the function moments to compute the moments of the process.\n\nmoments(coeff,x0,len_max,dim,T)\n\n\n\n\narray([1.        , 0.5       , 0.40803014, 0.36204521, 0.33448524,\n       0.31613774, 0.30305083, 0.29324856, 0.28563369, 0.27954838,\n       0.2745743 ])\n\n\n\n\nLaplace transform in the Brownian setting\nThe goal of this code is to compute the Laplace transform \\(\\mathbb E[e^{\\langle \\mathbf u^{sig}, \\mathbb X_t^{sig}\\rangle}]\\) and \\(\\mathbb E[e^{\\langle \\mathbf u^{pow}, \\mathbb X_t^{pow}\\rangle}]\\), where \\(X\\) denotes a Brownian motion and \\(\\mathbb X^{sig}\\) and \\(\\mathbb X^{pow}\\) the corresponding extensions. Precisely, we consider the following two extensions: the signature \\[\\mathbb X_t^{sig}:=(1,X_t,\\frac {X_t^2}2,\\ldots),\\] and the power sequence \\[\\mathbb X_t^{pow}:=(1,X_t,X_t^2,\\ldots).\\] As a first step import the following functions.\n\nfrom aff_poly_sig.riccati_bm import appr_exp_sig, appr_exp_pow, MC, CoD\n\nNext, we introduce the parameters of interest. We in particular have T for the time horizon, K_u for the lenght of (the approximation of) \\(\\mathbf u^{sig}\\) and \\(\\mathbf u^{pow}\\), u_sig for \\(\\mathbf u^{sig}\\) with the signature’s extension, and u_pow for \\(\\mathbf u^{pow}\\) with the power sequence’s extension. As an example we compute \\[\\mathbb E[\\exp(-2\\frac{X_t^2}2)]=\\mathbb E[\\exp(-X_t^2)]\\] for each \\(t\\in[0,T]\\), where \\(X\\) denotes a Brownian Motion and \\(T=1\\). The corresponding parameters are given in the following cell.\n\nimport math \nimport matplotlib.pyplot as plt\n\nT=1 # [0,T] time horizon\n\n#u in terms of the sig lift\nK_u=5\nu_sig=np.zeros(K_u) \nu_sig[2]=-2\n\n#u in terms of the powers lift\nu_pow=u_sig.copy()\nfor k in range(0,K_u):\n    u_pow[k]=u_pow[k]/math.factorial(k)\n\nOne then just needs to fix the computational parameters, namely the grid for the computation of the signature (timegrid) and the trucation’s level K for the solution.\n\nn_time=1000\ntimegrid = np.linspace(0,T,n_time)\nK=30\n\nThe desired Laplace transform can then be computed using appr_exp_sig and appr_exp_pow. The finals sig and pow denote the employed extensions.\n\nL_sig=appr_exp_sig(u_sig,timegrid,K)\nL_pow=appr_exp_pow(u_pow,timegrid,K)\n\nTo test the results, one can compare them to the results obtained by a Monte Carlo approximation. That’s what the MC function does.\n\nN=100000 # number of samples\nn_MC=1000 # number of times ticks\nMonteCarlo = MC(u_sig,T,n_MC,N)\n\n\n\n\n\n#Monte Carlo\n#MonteCarlo_CoD = CoD(np.real(MonteCarlo),n_MC, n_time)\nplt.plot(np.linspace(0,T,n_MC),MonteCarlo,'c',label='MC');\n\n#Sig Lift\nplt.plot(timegrid,L_sig,'m--',label='Sig');\n\n#Pow Lift\nplt.plot(timegrid,L_pow,'g:',label='Pow');\n\nplt.ylim(min(MonteCarlo.real-0.01),max(MonteCarlo.real)+0.01)\nplt.xlabel(\"t\")\nplt.title(f'Solving the Riccati for u_sig={u_sig.real} with an ODE solver')\nplt.legend();"
  },
  {
    "objectID": "riccati_bm.html",
    "href": "riccati_bm.html",
    "title": "Laplace transform in the Brownian setting",
    "section": "",
    "text": "Recall that \\(R\\) is the operator mapping the coefficients of \\(f\\) to the coefficients of \\[\\mathcal R f=\\frac 1 2 (f''(x)+f'(x)^2).\\]\n\n\nIn terms of signture it is given by \\[\nR(u)_k = \\frac{1}{2} \\big(u_{k+2} + \\sum_{i+j=k}\\binom k i u_{i+1}u_{j+1}\\big).\n\\] Since implementing an infinitely long sequence is not possibile, we also introduce a truncation’s parameter \\(K\\). We then set \\(R(u)_k=0\\) for each \\(k\\geq K\\).\n\nsource\n\n\n\n\n R_BM_sig (u, K)\n\n\n\n\nIn terms of power sequence the operator \\(R\\) is given by \\[\nR(u)_k = \\frac{1}{2} \\big((k+1)(k+2)u_{k+2} + \\sum_{i+j=k}(i+1)(j+1) u_{i+1}u_{j+1}\\big).\n\\] Since implementing an infinitely long sequence is not possibile, we also introduce a truncation’s parameter \\(K\\). We then set \\(R(u)_k=0\\) for each \\(k\\geq K\\).\n\nsource\n\n\n\n\n R_BM_pow (u, K)"
  },
  {
    "objectID": "riccati_bm.html#the-corresponding-odes",
    "href": "riccati_bm.html#the-corresponding-odes",
    "title": "Laplace transform in the Brownian setting",
    "section": "The corresponding ODEs",
    "text": "The corresponding ODEs\nWe are now investigating the following differential equations \\[\\begin{align*}\n\\frac{d}{dt} \\psi^{sig}(t) &= R^{sig}(\\psi^{sig}(t)),& \\psi^{sig}(0)&=u^{sig},\\\\\n\\frac{d}{dt} \\psi^{pow}(t) &= R^{pow}(\\psi^{pow}(t)),& \\psi^{pow}(0)&=u^{pow}.\n\\end{align*}\\] In order to resource to a standard solver (for real valued initial conditions) we need the following auxiliary functions.\n\nsource\n\nmodel_sig\n\n model_sig (psi, t, K)\n\n\nsource\n\n\nmodel_pow\n\n model_pow (psi, t, K)\n\nWe are now ready to define the function providing the solution of the Riccati equations given the initial condition and the other needed parameters.\n\nsource\n\n\nriccati_sol_sig\n\n riccati_sol_sig (u_sig, timegrid, K)\n\nSig lift\n\nsource\n\n\nriccati_sol_pow\n\n riccati_sol_pow (u_pow, timegrid, K)\n\nPow lift"
  },
  {
    "objectID": "riccati_bm.html#the-affine-transform-formula",
    "href": "riccati_bm.html#the-affine-transform-formula",
    "title": "Laplace transform in the Brownian setting",
    "section": "The affine transform formula",
    "text": "The affine transform formula\nFinally, we can use the affine transform formula to obtain an approximation of \\[\\mathbb E[\\exp(\\langle \\mathbf u,\\mathbb X_t\\rangle)]=\\mathbb E[\\exp(\\sum_{k=0}^\\infty \\mathbf u^{sig}_k \\frac{X_t^k}{k!})]=\\mathbb E[\\exp(\\sum_{k=0}^\\infty \\mathbf u^{pow}_k X_t^k)]\\] for each \\(t\\in[0,T]\\). It is given by \\[\\mathbb E[\\exp(\\sum_{k=0}^\\infty \\mathbf u^{sig}_k \\frac{X_t^k}{k!})]=\\exp(\\psi^{sig}(t)_0)\\qquad\\text{and}\\qquad\\mathbb E[\\exp(\\sum_{k=0}^\\infty \\mathbf u^{pow}_k \\frac{X_t^k}{k!})]=\\exp(\\psi^{pow}(t)_0),\\] respectively.\n\nsource\n\nappr_exp_sig\n\n appr_exp_sig (u_sig, timegrid, K)\n\nSig lift\n\nsource\n\n\nappr_exp_pow\n\n appr_exp_pow (u_pow, timegrid, K)\n\nPow lift"
  },
  {
    "objectID": "riccati_bm.html#numerical-experiments",
    "href": "riccati_bm.html#numerical-experiments",
    "title": "Laplace transform in the Brownian setting",
    "section": "Numerical experiments",
    "text": "Numerical experiments\nWe now implement the theory to approximate \\(\\mathbb E[\\exp(\\langle \\mathbf u,\\mathbb X_t\\rangle)]\\) for every \\(t\\in[0,T]\\).\n\nMonte Carlo\nThe next function provides reference values for our target. Observe that coefficients need to be inserted in their signature representation.\n\nsource\n\n\nMC\n\n MC (u_sig, T, n_MC, N)\n\nWe may need to use the following function for change of discretization’s grid.\n\nsource\n\n\nCoD\n\n CoD (old_vector, n_old, n_new)\n\n\n\nA first example\nAs a first test we compute \\[\\mathbb E[\\exp(-2\\frac{X_t^2}2)]=\\mathbb E[\\exp(-X_t^2)]\\] for each \\(t\\in[0,1]\\). The corresponding parameters are given in the following cell.\n\nT=1 # [0,T] time horizon\n\n#u in terms of the sig lift\nK_u=5\nu_sig=np.zeros(K_u, dtype=complex) \nu_sig[2]=-2\n\n#u in terms of the powers lift\nu_pow=u_sig.copy()\nfor k in range(0,K_u):\n    u_pow[k]=u_pow[k]/math.factorial(k)\n\nWe then compute the target values using Monte Carlo.\n\nN=100000 # number of samples\nn_MC=1000 # number of times ticks\nMonteCarlo = MC(u_sig,T,n_MC,N)\n\n\n\n\nWe set the time grid and the truncation level.\n\nn_time=1000 # number of times ticks for the plot\ntimegrid = np.linspace(0,T,n_time)\nK=30\n\nAnd plot the results.\n\n#Monte Carlo\nMonteCarlo_CoD = CoD(np.real(MonteCarlo),n_MC, n_time)\nplt.plot(timegrid,MonteCarlo_CoD,'c',label='MC');\n\n#Sig Lift\nplt.plot(timegrid,appr_exp_sig(u_sig,timegrid,K),'m--',label='Sig');\n\n#Pow Lift\nplt.plot(timegrid,appr_exp_pow(u_pow,timegrid,K),'g:',label='Pow');\n\nplt.ylim(min(MonteCarlo.real-0.01),max(MonteCarlo.real)+0.01)\nplt.xlabel(\"t\")\nplt.title(f'Solving the Riccati for u_sig={u_sig.real} with an ODE solver')\nplt.legend();\n\n\n\n\n\n#Sig Lift\nplt.plot(timegrid,appr_exp_sig(u_sig,timegrid,K)-MonteCarlo_CoD,'m--',label='Sig');\n\n#Pow Lift\nplt.plot(timegrid,appr_exp_pow(u_pow,timegrid,K)-MonteCarlo_CoD,'g:',label='Pow');\n\nplt.xlabel(\"t\")\nplt.title(f'Error for u_sig={u_sig.real}')\nplt.legend();\n\n\n\n\n\n\nA second example\nAs a first test we compute \\[\\mathbb E[\\exp(-\\exp{X_t})]=\\mathbb E[\\exp(\\sum_{k=0}^\\infty-\\frac{X_t^k}{k!})]=\\mathbb E[\\exp(\\sum_{k=0}^\\infty-\\frac1{k!}{X_t^k})]\\] for each \\(t\\in[0,1]\\). The corresponding parameters are given in the following cell.\n\nT=1 # [0,T] time horizon\n\n#u in terms of the sig lift\nK_u=20\nu_sig=-np.ones(K_u, dtype=complex) \n\n#u in terms of the powers lift\nu_pow=u_sig.copy()\nfor k in range(0,K_u):\n    u_pow[k]=u_pow[k]/math.factorial(k)\n\nWe then compute the target values using Monte Carlo. In order to avoid unnecessary errors we introduce an ad-hoc function.\n\ndef MC_exp(u_sig,T,n_MC,N):\n    tt=0\n    Lap = np.zeros(n_MC, dtype=complex)\n\n    for i in tqdm(range(n_MC)):\n        B_run= np.zeros((1,N))\n        B_run=np.random.normal(0,np.sqrt(tt), (1,N))\n        Lap[i]=np.mean(np.exp(-np.exp(B_run)))\n        tt+=T/n_MC\n    return Lap\n\n\nN=1000000 # number of samples\nn_MC=600 # number of times ticks\nMonteCarlo = MC_exp(u_sig,T,n_MC,N)\n\n\n\n\nWe set the time grid and the truncation level.\n\nn_time=1000 # number of times ticks for the plot\ntimegrid = np.linspace(0,T,n_time)\nK=K_u\n\nAnd plot the results.\n\n#Monte Carlo\nMonteCarlo_CoD = CoD(np.real(MonteCarlo),n_MC, n_time)\nplt.plot(timegrid,MonteCarlo_CoD,'c',label='Monte Carlo');\n\n#Pow Lift\nplt.plot(timegrid,appr_exp_pow(u_pow,timegrid,K),'b--',label='Pow-approximation');\n\n#Sig Lift\nplt.plot(timegrid,appr_exp_sig(u_sig,timegrid,K),'m:',label='Sig-approximation');\n\nplt.ylim(min(MonteCarlo.real-0.001),max(MonteCarlo.real)+0.001)\nplt.xlabel(\"t\")\nplt.ylabel(\"E[exp(-exp(X_t))]\")\nplt.title(f'Solving the Riccati for u_sig={u_sig.real} with an ODE solver')\nplt.legend();\n\n\n\n\n\n#Sig Lift\nplt.plot(timegrid,appr_exp_sig(u_sig,timegrid,K)-MonteCarlo_CoD,'m--',label='Sig');\n\n#Pow Lift\nplt.plot(timegrid,appr_exp_pow(u_pow,timegrid,K)-MonteCarlo_CoD,'g:',label='Pow');\n\nplt.xlabel(\"t\")\nplt.title(f'Error for u_sig={u_sig.real}')\nplt.legend();\n\n\n\n\n\n\nA third example\nAs a first test we compute \\[\\mathbb E[\\exp(-\\frac{X_t^4}{4!})]\\] for each \\(t\\in[0,1]\\). For this example we stick to the sig lift. The corresponding parameters are given in the following cell.\n\nT=1 # [0,T] time horizon\n\n#u in terms of the sig lift\nK_u=5\nu_sig=np.zeros(K_u, dtype=complex) \nu_sig[4]=-1\n\nWe then compute the target values using Monte Carlo.\n\nN=100000 # number of samples\nn_MC=1000 # number of times ticks\nMonteCarlo = MC(u_sig,T,n_MC,N)\n\n\n\n\nWe set the time grid and a range of truncation levels.\n\nn_time=1000 # number of times ticks for the plot\ntimegrid = np.linspace(0,T,n_time)\nK0=30 #initial value for K\nK=K0\nDK=10 #increments of K\nn_K=5 #number of K\n\nWe set several truncation levels and compute the corresponding approximations.\n\nappr_exp_siglist=[]\n\nfor i in tqdm(range(n_K)):\n    #Sig lift\n    appr_exp_siglist += [appr_exp_sig(u_sig,timegrid,K),]\n    K+=DK\n\n\n\n\n\nindices=[]\nfor k in range(n_K):\n    delta=appr_exp_siglist[k][1:]-appr_exp_siglist[k][:-1]\n    delta=delta[:len(appr_exp_siglist[k])-1]\n    #Cutting after the explosion\n    cond1=np.where(delta>0.01)[0]\n    cond2=np.where(delta<-0.01)[0]\n    index=len(appr_exp_siglist[k])-1\n    if len(cond1)>0:\n        index=cond1[0]\n    if len(cond2)>0:\n        index=min(index,cond2[0])\n    indices+=[index+2,]\n\nAnd plot the results for different \\(K\\).\n\n#Monte Carlo\nMonteCarlo_CoD = CoD(np.real(MonteCarlo),n_MC, n_time)\nplt.plot(timegrid,MonteCarlo_CoD,'c',label='MC');\n\nfor i in range(n_K):\n    K=K0+i*DK\n    #Sig Lift\n    plt.plot(timegrid[:indices[i]],np.minimum(appr_exp_siglist[i][:indices[i]],max(MonteCarlo.real)+10*np.ones(indices[i])),'--',label=f'Sig-approx with K={K}');\n\n\nplt.ylim(min(MonteCarlo.real-0.01),max(MonteCarlo.real)+0.01)\nplt.xlabel(\"t\")\nplt.title(f'Solving the Riccati for u_sig={u_sig.real} with an ODE solver')\nplt.legend();\n\n\n\n\nAs one can see the proposed numerical method is not working for this example. Alternatively, we propose to use the transport equation."
  },
  {
    "objectID": "riccati_bm.html#riccati-transport-equation",
    "href": "riccati_bm.html#riccati-transport-equation",
    "title": "Laplace transform in the Brownian setting",
    "section": "Riccati-transport equation",
    "text": "Riccati-transport equation\nWe now illustrate how to resource to the transport equation to compute \\[v(t,u):=\\mathbb E\\Big[\\exp\\Big(\\sum_{k=0}^\\infty u_k\\frac {X_t^k}{k!}\\Big)\\Big].\\] This method is appearing to be more stable than then more direct one presented above.\nRecall that setting \\[v(0,u)=\\exp(u_0)\\qquad\\text{and}\\qquad R(u)_k = \\frac{1}{2} \\big(u_{k+2} + \\sum_{i+j=k}\\binom k i u_{i+1}u_{j+1}\\big),\\] we obtain that \\(v\\) satisfies the transport equation \\(\\partial_t v(t,u)=\\partial_u^{R(u)}v(t,u),\\) where \\[\\partial_u^{R(u)}v(t,u)=\\lim_{M\\to\\infty}M\\Big(v(t,u+\\frac {R(u)}M)-v(t,u)\\Big).\\]\n\nNumerical scheme\nDiscretizing both derivatives we get \\[(T/N)^{-1}\\Big(v(t+\\frac T N,u)-v(t,u)\\Big)\n\\approx \\partial_t v(t,u)\n= \\partial_u^{R(u)}v(t,u)\n\\approx M\\Big(v(t,u+\\frac {R(u)}M)-v(t,u)\\Big),\\] which leads to \\[\\begin{align*}\nv(t,u)\n&\\approx v(t-\\frac T N,u)+ \\frac{MT}N\\Big(v(t-\\frac T N,u+\\frac {R(u)}M)-v(t-\\frac T N,u)\\Big)\\\\\n&=\\lambda(v(t-\\frac T N,A_M(u))+ (1-\\lambda)v(t-\\frac T N,u),\n\\end{align*}\\] for \\(\\lambda:=MT/N\\) and \\(A_M(u):=u+{R(u)}/M\\). Starting with \\(t=Tn/N\\) and repeating the procedure \\(n\\) times we thus obtain \\[\\begin{align*}\nv(Tn/N,u)\n&\\approx\\sum_{m=0}^n \\binom n m(1-\\lambda)^{n-m}\\lambda^mv(0,A_M^{\\circ m}(u))\\\\\n&=\\sum_{m=0}^n \\binom n m(1-\\lambda)^{n-m}\\lambda^m \\exp(A_M^{\\circ m}(u)_0)\n.\n\\end{align*}\\]\nTruncation: The only value of \\(A_M(u)\\) that matters for the result is the 0-th. Due to the form of \\(R\\), the only terms of \\(u\\) that enters in \\(A_M(u)_0\\) are \\(u_0\\) and \\(u_2\\). Since we need to apply \\(A_M(u)\\) at most \\(N\\) times, a truncation at level \\(K\\geq 2N\\) will not affect the result. We thus fix \\(K:=2N\\).\n\nsource\n\n\nA_M\n\n A_M (M, u_sig, K)\n\n\nsource\n\n\nvTu\n\n vTu (u, T, N, M)\n\n\n\nBack to our third example\nAs a first test we compute \\[\\mathbb E[\\exp(-\\frac{W_t^4}{4!})]\\] for each \\(t\\in[0,1]\\). For this example we stick to the sig lift. The corresponding parameters are given in the following cell.\n\nT=1 # [0,T] time horizon\n\n#u in terms of the sig lift\nK_u=5\nu_sig=np.zeros(K_u, dtype=complex) \nu_sig[4]=-1\n\nWe then compute the target values using Monte Carlo.\n\nN=100000 # number of samples\nn_MC=1000 # number of times ticks\nMonteCarlo = MC(u_sig,T,n_MC,N)\n\n\n\n\nWe set the time grid for Monte Carlo.\n\ntime_MC = np.linspace(0,T,n_MC)\n\nWe are now ready to plot the result.\n\nN=80#number of time's ticks\nK=N*2 #truncation\nM0=50 \nM=M0 #R(u)/M = increment for space derivative\n\nn_k=4 #number of curves to plot\nincr_M= 10 #increment of M from curve to curve\n\n\nplt.plot(time_MC,MonteCarlo,'c',label='MC');\n\n\nfor l in tqdm(range(n_k)):\n    time_run = np.linspace(0,T,N)\n    space = vTu(u_sig.real,T,N,M)\n    \n    #Cutting after the explosion\n    cond1=np.where(space>1.1)[0]\n    cond2=np.where(space<0.91)[0]\n    index=len(space)-1\n    if len(cond1)>0:\n        index=cond1[0]\n    if len(cond2)>0:\n        index=min(index,cond2[0])\n    space_toplot = space[:index+1]\n    \n    plt.plot(time_run[:len(space_toplot)],space_toplot,'--',label=f'Sig-approx with M={M}');\n    M+=10\n    \nplt.ylim(0.9, 1.01)  \nplt.xlabel(\"t\")\n#plt.title(f'E[exp(<u_sig,X_t>)] for u={u_sig.real}')  \nplt.legend();"
  },
  {
    "objectID": "exp_sig_poly_proc.html",
    "href": "exp_sig_poly_proc.html",
    "title": "Expected signature of polynomial processes in \\((d+1)\\)-dimensions",
    "section": "",
    "text": "First, we need to define some maps mapping a multiindex to its lexicographic order and back.\n\nsource\n\n\n\n fromwordtonum (I, d)\n\nProviding the number corresponding to the multiindex I in a vocabulary of words of letters {0,…,d}.\n\nsource\n\n\n\n\n fromnumtoword (n, d)\n\nProviding the multiindex corresponding to the number n in a vocabulary of words of letters {0,…,d}.\n\nsource\n\n\n\n\n fromlentonum (len_max, d)\n\nProviding the maximal component of a vector with all multiindices of lenght<=len_max.\nWe introduce then the shuffle product and its vectorial representation.\n\nsource\n\n\n\n\n shuffle (a, b)\n\nInput: a,b: multiindices\nOutput: list of multiindices in a shuffle b\n\nsource\n\n\n\n\n shuffletensor (len_1, len_2, d)\n\nInput: len_1,len_2: maximal lenght of the input’s multiindices {0,…,d} denotes the set of indices\nOutput: tensor"
  },
  {
    "objectID": "exp_sig_poly_proc.html#from-polynomials-to-linear-combinations-of-the-signature",
    "href": "exp_sig_poly_proc.html#from-polynomials-to-linear-combinations-of-the-signature",
    "title": "Expected signature of polynomial processes in \\((d+1)\\)-dimensions",
    "section": "From polynomials to linear combinations of the signature",
    "text": "From polynomials to linear combinations of the signature\nRecall that for every symmetric matrix \\(c_2\\) \\[\\begin{align*}\np(X_t)&=c_0+ c_1^\\top X_t+Tr(c_2 X_tX_t^\\top)\\\\\n&=(c_0+c_1^\\top X_0+ Tr(c_2 X_0X_0^\\top))\\pi_0(\\mathbb X_t)\n+(c_1^\\top +2X_0^\\top c_2 )\\pi_1(\\mathbb X_t)\n+2Tr(c_2 \\pi_2(\\mathbb X_t)).\n\\end{align*}\\] Given \\(c_0,c_1,c_2\\) and \\(X_0\\) the function polytosig returns a vector \\(csig\\) such that \\[csig^\\top vec(\\mathbb X^{\\leq 2})=p(X_t).\\]\n\nsource\n\npolytosig\n\n polytosig (c0, c1, c2, x0)\n\nInput: c0: float c1,c2,x0: array_like\nc0,c1,c2 denotes the coefficient of a polynomial parametrized as number, vector, and matrix.\nx0 denotes the initial value of the considered process.\nOutput: np.array\ncoefficients of the truncated signature in the corresponding representation\nNext, we need to initialize the coefficents. Suppose that the dynamics of a polynomial process \\(X\\) are given by a drift vector \\[b(X_t)^i=b_i+\\sum_{j=0}^db_{ij}X_t^j,\\] a diffusion matrix \\[a(X_t)^{ij}=a_{ij}+\\sum_{k=0}^da_{ijk}X_t^k+\\sum_{k,h=0}^da_{ijkh}X_t^kX_t^h,\\] and an initial condition \\(x_0\\). Set then \\[\\begin{align*}\nb_{const}[i]&=b_i,& b_{lin}[i,j]&=b_{ij},\\\\\na_{const}[i,j]&=a_{ij},& a_{lin}[i,j,k]&=a_{ijk},& a_{quad}[i,j,k,h]=a_{ijkh}.\n\\end{align*}\\] The function polytosigvec maps the coefficients \\([b_{const},b_{lin},a_{const},a_{lin},a_{quad}]\\) and \\(x_0\\) to \\([bsig,asig]\\) such that \\[bsig[i]^\\top vec(\\mathbb X^{\\leq 2})=b(X_t)^i\\qquad\\text{and}\\qquad asig[i,j]^\\top vec(\\mathbb X^{\\leq 2})=a(X_t)^{ij}.\\]\n\nsource\n\n\npolytosigvec\n\n polytosigvec (coeff, x0)\n\nInput: coeff: list x0 : array_like\ncoeff denotes the list of coefficients [b_{const},b_{lin},a_{const},a_{lin},a_{quad}]\nx0 denotes the initial value of the process\nOutput: list list[0] is an np.array with coefficients of the truncated signature in the representation of b(X) list[1] is an np.array with coefficients of the truncated signature in the representation of a(X)"
  },
  {
    "objectID": "exp_sig_poly_proc.html#expected-signature-of-polynomial-processes",
    "href": "exp_sig_poly_proc.html#expected-signature-of-polynomial-processes",
    "title": "Expected signature of polynomial processes in \\((d+1)\\)-dimensions",
    "section": "Expected signature of polynomial processes",
    "text": "Expected signature of polynomial processes\nWe are now ready to implement the operator \\[Le_I=e_{I'}\\# b^{i_{|I|}}+\\frac 1 2 e_{I''}\\# a^{i_{|I|-1},i_{|I|}}.\\] In the vectorial representation \\(L\\) can be written as a matrix \\(matrix(L)\\) such that \\[matrix(L) vec(e_I)=vec(Le_I).\\]\n\nsource\n\nmatrixL\n\n matrixL (coeff, x0, len_max, dim)\n\nInput: coeff: list x0 : array_like len_max,dim: float\ncoeff denotes the list of coefficients [b_{const},b_{lin},a_{const},a_{lin},a_{quad}]\nx0 denotes the initial value of the process \nlen_max and dim denote the desired truncation level and the dimension of X, respectively.\nOutput: np.ndarray\nthe matrix corresponding to the generator of the signature trucated at level len_max of the corresponding process.\nResourcing to the polynomial formula we can now compute the expected signature \\(\\mathbb E[\\mathbb X_T^{\\leq len_{max}}].\\)\n\nsource\n\n\nexpsig\n\n expsig (coeff, x0, len_max, dim, T)\n\nInput: coeff: list x0 : array_like len_max,dim,T: float\ncoeff denotes the list of coefficients [b_{const},b_{lin},a_{const},a_{lin},a_{quad}]\nx0 denotes the initial value of the process \nlen_max and dim denote the desired truncation level and the dimension of X, respectively.\nT denotes the time\nOutput: np.array\nvector corresponding to E[Sig(X)_T^{len_max}]\nTo better read the oputput of expsig we also provide a function associating to each non-zero coponent of the expected signature its multiindex. Alternatively, the function expsig_withwords concatenate the two functions.\n\nsource\n\n\nwithwords\n\n withwords (Expsig, dim)\n\nInput: Expsig: array_like dim: float\nExpsig denotes the output of the function expsig\nOutput: list\nlist of non-zero components of the signature together with the corresponding multiindex.\n\nsource\n\n\nexpsig_withwords\n\n expsig_withwords (coeff, x0, len_max, dim, T)\n\nInput: coeff: list x0 : array_like len_max,dim,T: float\ncoeff denotes the list of coefficients [b_{const},b_{lin},a_{const},a_{lin},a_{quad}]\nx0 denotes the initial value of the process \nlen_max and dim denote the desired truncation level and the dimension of X, respectively.\nT denotes the time\nOutput: list\nlist of non-zero components of the signature together with the corresponding multiindex.\nIn one dimension, one can obtain the moments of a process from the expected signature by means of the simple formula \\[X_t^k=k!\\sum_{i=0}^k\\frac{X_0^{k-i}}{(k-i)!}\\langle e_0^{\\otimes i},\\mathbb X_t\\rangle.\\]\n\nsource\n\n\nmoments\n\n moments (coeff, x0, len_max, dim, T)"
  },
  {
    "objectID": "exp_sig_poly_proc.html#examples",
    "href": "exp_sig_poly_proc.html#examples",
    "title": "Expected signature of polynomial processes in \\((d+1)\\)-dimensions",
    "section": "Examples",
    "text": "Examples\n\nExpected signature and moments of a Brownian motion\nAs a first step we need to introduce the coefficients of the polynomial process.\n\ndim=1\n\nb_const=np.zeros(dim)\nb_lin=np.zeros((dim,dim))\na_const=np.zeros((dim,dim))\na_lin=np.zeros((dim,dim,dim))\na_quad=np.zeros((dim,dim,dim,dim))\n\na_const[0]=1\n\ncoeff=(b_const,b_lin,a_const,a_lin,a_quad)\n\nx0=np.zeros(dim)\n\nlen_max=10\nT=1\n\nNext, we run the proposed code for the expected signature.\n\nExpsig=expsig(coeff,x0,len_max,dim,T)\n\n\n\n\nAnd finally we obtain a readable output.\n\nwithwords(Expsig,dim)\n\n[[1.0, []],\n [0.5, [0, 0]],\n [0.125, [0, 0, 0, 0]],\n [0.020833333333333332, [0, 0, 0, 0, 0, 0]],\n [0.002604166666666666, [0, 0, 0, 0, 0, 0, 0, 0]],\n [0.00026041666666666655, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]\n\n\nWith the apposite code one can also get the corresponding moments.\n\nmoments(coeff,x0,len_max,dim,T)\n\n\n\n\narray([  1.,   0.,   1.,   0.,   3.,   0.,  15.,   0., 105.,   0., 945.])\n\n\n\n\nTime extended 2 dimensional Brownian Motion\nAs a first step we need to introduce the coefficients of the polynomial process.\n\ndim=3\n\nb_const=np.zeros(dim)\nb_lin=np.zeros((dim,dim))\na_const=np.zeros((dim,dim))\na_lin=np.zeros((dim,dim,dim))\na_quad=np.zeros((dim,dim,dim,dim))\n\nb_const[0]=1\na_const[1,1]=1\na_const[2,2]=1\n\ncoeff=(b_const,b_lin,a_const,a_lin,a_quad)\n\nx0=np.zeros(dim)\n\nlen_max=5\nT=1\n\nFinally, we run the proposed code with a readable output.\n\nexpsig_withwords(coeff,x0,len_max,dim,T)\n\n\n\n\n[[1.0, []],\n [1.0, [0]],\n [0.5, [0, 0]],\n [0.5, [1, 1]],\n [0.5, [2, 2]],\n [0.16666666666666666, [0, 0, 0]],\n [0.25, [0, 1, 1]],\n [0.25, [0, 2, 2]],\n [0.25, [1, 1, 0]],\n [0.25, [2, 2, 0]],\n [0.04166666666666666, [0, 0, 0, 0]],\n [0.08333333333333333, [0, 0, 1, 1]],\n [0.08333333333333333, [0, 0, 2, 2]],\n [0.08333333333333333, [0, 1, 1, 0]],\n [0.08333333333333333, [0, 2, 2, 0]],\n [0.08333333333333333, [1, 1, 0, 0]],\n [0.125, [1, 1, 1, 1]],\n [0.125, [1, 1, 2, 2]],\n [0.08333333333333333, [2, 2, 0, 0]],\n [0.125, [2, 2, 1, 1]],\n [0.125, [2, 2, 2, 2]],\n [0.00833333333333333, [0, 0, 0, 0, 0]],\n [0.02083333333333333, [0, 0, 0, 1, 1]],\n [0.02083333333333333, [0, 0, 0, 2, 2]],\n [0.02083333333333333, [0, 0, 1, 1, 0]],\n [0.02083333333333333, [0, 0, 2, 2, 0]],\n [0.02083333333333333, [0, 1, 1, 0, 0]],\n [0.041666666666666664, [0, 1, 1, 1, 1]],\n [0.041666666666666664, [0, 1, 1, 2, 2]],\n [0.02083333333333333, [0, 2, 2, 0, 0]],\n [0.041666666666666664, [0, 2, 2, 1, 1]],\n [0.041666666666666664, [0, 2, 2, 2, 2]],\n [0.02083333333333333, [1, 1, 0, 0, 0]],\n [0.041666666666666664, [1, 1, 0, 1, 1]],\n [0.041666666666666664, [1, 1, 0, 2, 2]],\n [0.041666666666666664, [1, 1, 1, 1, 0]],\n [0.041666666666666664, [1, 1, 2, 2, 0]],\n [0.02083333333333333, [2, 2, 0, 0, 0]],\n [0.041666666666666664, [2, 2, 0, 1, 1]],\n [0.041666666666666664, [2, 2, 0, 2, 2]],\n [0.041666666666666664, [2, 2, 1, 1, 0]],\n [0.041666666666666664, [2, 2, 2, 2, 0]]]\n\n\n\n\nThe Jacobi Process\n\ndim=1\n\nb_const=np.zeros(dim)\nb_lin=np.zeros((dim,dim))\na_const=np.zeros((dim,dim))\na_lin=np.zeros((dim,dim,dim))\na_quad=np.zeros((dim,dim,dim,dim))\n\na_lin[0]=1\na_quad[0]=-1\n\ncoeff=(b_const,b_lin,a_const,a_lin,a_quad)\n\nx0=np.zeros(dim)\nx0[0]=1/2\n\nlen_max=10\nT=10000\n\n\n#Expsig=\nexpsig(coeff,x0,len_max,dim,T)\n#withwords(Expsig,dim)\n\n\n\n\narray([1.00000000e+00, 0.00000000e+00, 1.25000000e-01, 0.00000000e+00,\n       2.60416667e-03, 0.00000000e+00, 2.17013889e-05, 0.00000000e+00,\n       9.68812004e-08, 0.00000000e+00, 2.69114446e-10])\n\n\n\nlen_max=20\n\nMoments=moments(coeff,x0,len_max,dim,T)\n\n\n\n\n\ndef expc(c):\n    u=np.ones(len(Moments))\n    for k in range(len(u)):\n        u[k]=c**k/math.factorial(k)\n    return u\n\nspace=np.linspace(-5,5,100)\n\nstationary=1/2*(1+np.exp(space))\n\nplt.plot(space,stationary,label=f'Stat'); \n\nfor j in range(2,11,1):\n    MGF=np.ones(len(space))\n    for k in range(len(MGF)):\n        MGF[k]=np.dot(expc(space[k])[:j],Moments[:j])\n    plt.plot(space,MGF,label=f'K={j}');    \n\n\nplt.xlabel(\"c\")\nplt.ylabel(f'E[exp($cX_{T}$)]')\nplt.title(f'Computing the MGF of a Jacobi diffusion with $X_0=${x0[0]}')\nplt.legend();"
  }
]