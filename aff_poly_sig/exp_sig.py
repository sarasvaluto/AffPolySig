# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/exp_sig_poly_proc.ipynb.

# %% auto 0
__all__ = ['fromwordtonum', 'fromnumtoword', 'fromlentonum', 'shuffle', 'shuffletensor', 'polytosig', 'polytosigvec', 'matrixL',
           'expsig', 'withwords', 'expsig_withwords', 'moments']

# %% ../nbs/exp_sig_poly_proc.ipynb 3
import numpy as np
import math 
import scipy.special
from scipy.linalg import expm, sinm, cosm
import cmath
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from tqdm.auto import tqdm
import time
import fractions
from itertools import permutations

# %% ../nbs/exp_sig_poly_proc.ipynb 5
def fromwordtonum(I,d):
    '''
    Providing the number corresponding to the multiindex I in a vocabulary of words of letters {0,...,d}.
    '''
    if len(I)==0:
        return 0
    powers=np.ones(len(I))
    for i in range(len(I)):
        powers[i]=(d+1)**i
    powers=np.flip(powers)
    all0but1=np.ones(len(I))
    all0but1[-1]=0
    return int(np.dot(I+all0but1,powers))+1

# %% ../nbs/exp_sig_poly_proc.ipynb 6
def fromnumtoword(n,d):
    '''
    Providing the multiindex corresponding to the number n in a vocabulary of words of letters {0,...,d}.
    '''
    if n==0:
        return []
    else:
        return fromnumtoword((n-1)//(d+1),d)+[(n-1)%(d+1),]

# %% ../nbs/exp_sig_poly_proc.ipynb 7
def fromlentonum(len_max,d):
    '''
    Providing the maximal component of a vector with all multiindices of lenght<=len_max. 
    '''
    maxword=d*np.ones(len_max)
    return fromwordtonum(maxword,d)

# %% ../nbs/exp_sig_poly_proc.ipynb 9
def shuffle(a,b):
    '''
    Input:
        a,b: multiindices
    
    Output:
        list of multiindices in a shuffle b
    '''
    sh = []
    if len(a)==0:
        return [b,]
    if len(b)==0:
        return [a,]
    else:
        [sh.append(p+[a[-1],]) for p in shuffle(a[:-1],b)]
        [sh.append(p+[b[-1],]) for p in shuffle(a,b[:-1])]
    return sh

# %% ../nbs/exp_sig_poly_proc.ipynb 10
def shuffletensor(len_1,len_2,d):
    '''
    Input:
        len_1,len_2: maximal lenght of the input's multiindices
        {0,...,d} denotes the set of indices
    
    Output:
        tensor
    '''
    dim1=fromlentonum(max(len_1,len_2),d)+1
    dim2=fromlentonum(min(len_1,len_2),d)+1
    dim_out=fromlentonum(len_1+len_2,d)+1
    tensor=np.zeros((dim1,dim2,dim_out))
    tensor[0,0,0]=1
    for i in range(1,dim1):
        tensor[i,0,i]=1
        if i<dim2:
            tensor[0,i,i]=1
        for j in range (1,min(i+1,dim2)):
            wordi=fromnumtoword(i,d)
            wordj=fromnumtoword(j,d)
            shufflelist=shuffle(wordi,wordj)
            for word in shufflelist:
                tensor[i,j,fromwordtonum(word,d)]+=1
                if i !=j and i<dim2:
                    tensor[j,i,fromwordtonum(word,d)]+=1
    if len_2>len_1:
        tensor=np.swapaxes(tensor, 0, 1)
    return tensor

# %% ../nbs/exp_sig_poly_proc.ipynb 12
def polytosig(c0,c1,c2,x0):
    '''
    Input:
        c0: float
        c1,c2,x0: array_like
        
        c0,c1,c2 denotes the coefficient of a polynomial parametrized as number, vector, and matrix.
        x0 denotes the initial value of the considered process.
    
    Output:
        np.array
        
        coefficients of the truncated signature in the corresponding representation
    '''
    c2sim=(c2+np.transpose(c2))/2
    csig=c0+np.dot(c1,x0)+np.tensordot(np.tensordot(x0,x0,axes=0),c2sim,axes=([0,1],[0,1]))
    csig=np.concatenate((csig,c1+2*np.dot(x0,c2sim)),axis=None)
    csig=np.concatenate((csig,2*np.squeeze(np.asarray(c2sim))),axis=None)
    return csig

# %% ../nbs/exp_sig_poly_proc.ipynb 14
def polytosigvec(coeff,x0):
    '''
    Input:
        coeff: list
        x0 : array_like
        
        coeff denotes the list of coefficients [b_{const},b_{lin},a_{const},a_{lin},a_{quad}]
        x0 denotes the initial value of the process
    
    Output: list
        list[0] is an np.array with coefficients of the truncated signature in the representation of b(X)
        list[1] is an np.array with coefficients of the truncated signature in the representation of a(X)
    '''
    b_const=coeff[0]
    b_lin=coeff[1]
    a_const=coeff[2]
    a_lin=coeff[3]
    a_quad=coeff[4]
    
    dim=len(b_const)
    bsig=np.zeros((dim,1+dim+dim**2))
    asig=np.zeros((dim,dim,1+dim+dim**2))
    for i in range(dim):
        bsig[i]=polytosig(b_const[i],b_lin[i,:],np.zeros((dim,dim)),x0)
        for j in range(dim):
            asig[i,j]=polytosig(a_const[i,j],a_lin[i,j,:],a_quad[i,j,:],x0)
    return bsig,asig

# %% ../nbs/exp_sig_poly_proc.ipynb 16
def matrixL(coeff,x0,len_max,dim):
    '''
    Input:
        coeff: list
        x0 : array_like
        len_max,dim: float

        coeff denotes the list of coefficients [b_{const},b_{lin},a_{const},a_{lin},a_{quad}]
        x0 denotes the initial value of the process 
        len_max and dim denote the desired truncation level and the dimension of X, respectively.
        
    Output:
        np.ndarray
        
        the matrix corresponding to the generator of the signature trucated at level len_max of the corresponding process.
    '''
    d=dim-1
    dimL=fromlentonum(len_max,d)+1
    sigcoeff=polytosigvec(coeff,x0)
    shuffletens=shuffletensor(2,len_max-1,d)[:,:,:dimL]
    
    L=np.zeros((dimL))
    for n in tqdm(range(1,dimL)):
        word=fromnumtoword(n,d)
        numprime=fromwordtonum(word[:-1],d)
        L_run=np.tensordot(sigcoeff[0][word[-1]],shuffletens,axes=([-1],[0]))[numprime,:]
        numsecond=fromwordtonum(word[:-2],d)
        if len(word)>1:
            L_run+=1/2*np.tensordot(sigcoeff[1][tuple(word[-2:])],shuffletens,axes=([-1],[0]))[numsecond,:]
        L=np.vstack((L,L_run))
    return L

# %% ../nbs/exp_sig_poly_proc.ipynb 18
def expsig(coeff,x0,len_max,dim,T):
    '''
    Input:
        coeff: list
        x0 : array_like
        len_max,dim,T: float

        coeff denotes the list of coefficients [b_{const},b_{lin},a_{const},a_{lin},a_{quad}]
        x0 denotes the initial value of the process 
        len_max and dim denote the desired truncation level and the dimension of X, respectively.
        T denotes the time
        
    Output:
        np.array
        
        vector corresponding to E[Sig(X)_T^{len_max}]
    '''
    matL=matrixL(coeff,x0,len_max,dim)
    #print('Shape of the L-matrix',matL.shape)
    return expm(T*matL)[:,0]

# %% ../nbs/exp_sig_poly_proc.ipynb 20
def withwords(Expsig,dim):
    '''
    Input:
        Expsig: array_like
        dim: float

        Expsig denotes the output of the function expsig
        
    Output:
        list
        
        list of non-zero components of the signature together with the corresponding multiindex.
    '''
    d=dim-1
    listofwords=[]
    for n in range(len(Expsig)):
        if Expsig[n]!=0:
            #listofwords+=[[str(fractions.Fraction(Expsig[n]).limit_denominator()),fromnumtoword(n,d)],]
            listofwords+=[[Expsig[n],fromnumtoword(n,d)],]
    return listofwords

# %% ../nbs/exp_sig_poly_proc.ipynb 21
def expsig_withwords(coeff,x0,len_max,dim,T):
    '''
    Input:
        coeff: list
        x0 : array_like
        len_max,dim,T: float

        coeff denotes the list of coefficients [b_{const},b_{lin},a_{const},a_{lin},a_{quad}]
        x0 denotes the initial value of the process 
        len_max and dim denote the desired truncation level and the dimension of X, respectively.
        T denotes the time
        
    Output:
        list
        
        list of non-zero components of the signature together with the corresponding multiindex.
    '''
    Expsig=expsig(coeff,x0,len_max,dim,T)
    return withwords(Expsig,dim)

# %% ../nbs/exp_sig_poly_proc.ipynb 23
def moments(coeff,x0,len_max,dim,T):
    Expsig=expsig(coeff,x0,len_max,dim,T)
    powers=np.ones(len(Expsig))
    for k in range(1,len(Expsig)):
        powers[k]=x0[0]**k/math.factorial(k)
    mom=np.ones(len(Expsig))
    for k in range(len(Expsig)):
        mom[k]=math.factorial(k)*np.dot(np.flip(powers[:k+1]),Expsig[:k+1])
    return mom  
